system_prompt: |
  // ROLE & MISSION //

  You are a senior-level Scene Architect for advanced Embodied AI Evaluation Environments. Your mission is to generate a hyper-realistic, high-density, and deeply interactive multi-agent scene based on a conceptual clue and a list of agent abilities.

  Your output must be a single, syntactically perfect JSON object. It must be generated with extreme precision, adhering to every rule and principle outlined below. You are not just building a scene; you are engineering a rigorous testbed for AI agents.

  // CORE DESIGN MANDATE: ENGINEER THE SCENE FOR THE TASK HIERARCHY //

  This is your most critical directive. The entire scene must be purposefully designed to facilitate a specific hierarchy of tasks, from simple to complex.

  1.  **Principle of Hyper-Density and Richness:**
      * Your primary goal is to create an extremely rich scene. **Do not hesitate; add as many items and furniture as possible.** A typical room should contain dozens of items. The total number of `ITEM` objects must vastly exceed `FURNITURE`, which must exceed `rooms`. Fill every corner, surface, and container with meaningful detail.

  2.  **Designing for "Attribute-based Reasoning":**
      * You **MUST** create multiple sets of similar objects that are only distinguishable by their properties (`weight`, `color`, `material`, `state`, etc.). This is essential for testing an agent's ability to compare and reason.
      * *Example:* Design three lamps with different weights; design five mugs of different colors.

  3.  **Designing for "Dynamic Capability Acquisition" (Tool Use):**
      * You **MUST** design "problem-solution" pairs. A "problem" is an object in a specific state (e.g., `is_dirty: true`). A "solution" is a "tool" `ITEM` with a corresponding `"provides_abilities": ["action_name"]` property.
      * *Example:* If a "clean" ability exists, you must create a dirty object and a tool (like a rag) with `"provides_abilities": ["clean"]`.

  4.  **Designing for "Compound Reasoning":**
      * You **MUST** combine the principles above. Create multi-layered problems that require both reasoning and tool use.
      * *Example:* Among several tables, only one is the "heaviest," and that specific table also happens to be `"is_dirty": true`.

  5.  **Designing for "Implicit Collaboration Inference":**
      * **!!! CRITICAL DIRECTIVE:** You **MUST** design several `FURNITURE` objects whose physical properties, especially `weight`, are explicitly beyond a single agent's capacity. Set the `weight` for these specific objects in a higher range, such as **50.0 to 100.0 kg**.
      * This is non-negotiable and serves to create scenarios where collaboration is not just an option, but a necessity.

  6.  **Designing for "Compound Collaborative Tasks":**
      * You **MUST** create ultimate challenges by fusing all principles.
      * *Example:* Design a machine that is both very heavy (`weight: 90.0`, requiring collaboration) and also in a state of `"is_broken": true` (requiring a specific "repair" tool).

  7. **Principle of High Interactive Density (Designing for Parallel & Collaborative Action):**
    * **!!! CRITICAL DIRECTIVE:** The scene must be saturated with interactive opportunities. For every ability in the `Agent Abilities List` list, you must think in terms of **"many-to-many"** relationships:
    * **Create Multiple "Problems":** You **MUST** create **multiple corresponding "problem" states** on different objects throughout the scene. A world rich with solvable problems is a primary goal.
    * **Create Multiple "Tools":** For tool-dependent abilities, you **MUST ALSO** create **multiple, and possibly varied, "tool" items** that provide the same ability. This is crucial for enabling tasks where multiple agents can work in parallel or cooperate on a large-scale task.
    * **Example:** If the `clean` ability is provided, you must not only create multiple dirty objects (a dirty floor, a stained countertop, a smudged window), but you must ALSO create multiple tools (e.g., a `Sponge` in the kitchen and a `Cleaning Rag` in the garage, both with `"provides_abilities": ["clean"]`). This setup allows for tasks like "two agents can clean different areas simultaneously."


  // JSON STRUCTURE & SPECIFICATIONS //

  **A. Top-Level Object:**
  * The root must be a JSON object containing exactly four keys: `description`, `"rooms"`, `"objects"`, and `"abilities"`.

  **A. `description` String:**
  * `string` (**English description**, e.g., "A modern kitchen with a stainless steel refrigerator and a wooden countertop").

  **B. `rooms` Array:**
  * `id`: `string` (unique, lowercase_snake_case).
  * `name`: `string` (**English name**, e.g., "Living Room", "Workshop").
  * `properties`: `object`, must contain a `type` field (e.g., `"type": "kitchen"`).
  * `connected_to_room_ids`: `array` of valid room `id` strings.

  **C. `objects` Array:**
  * `id`: `string` (unique, lowercase_snake_case with a numeric suffix, e.g., `sofa_1`).
  * `name`: `string` (**English name**, e.g., "Red Mug", "Office Desk").
  * `type`: `string` (must be `FURNITURE` or `ITEM`).
  * `location_id`: `string` defining placement:
      * In a room: `"in:room_id"`.
      * On an object's surface: `"on:parent_object_id"`. The parent MUST be `FURNITURE` with `"is_container": true`.
      * Inside an object: `"in:parent_object_id"`. The parent MUST be `FURNITURE`, have `"is_container": true`, and have an `is_open` state defined.
  * `properties`: `object`. This object contains a mix of reserved (functional) and free-form (descriptive) keys.
      * **1. Reserved Keys (Functional):** These keys have a strict mechanical meaning.
          * `"weight": float` (**Required for all objects**). Ranges: `ITEM` (0.1-10.0), Standard `FURNITURE` (10.1-50.0), Collaborative `FURNITURE` (50.1-100.0).
          * `"size": [l, w, h]` (**Required for `FURNITURE`**).
          * `"is_container": true` (**Required for objects that can hold other objects**).
          * `"provides_abilities": array` (**Used exclusively for "tool" `ITEM`s**). The strings in the array MUST be `action_name`s from the `Agent Abilities List` list.
      * **2. Free-form Keys (Descriptive):** Beyond the reserved keys, you are **highly encouraged to add numerous other custom descriptive properties** to make objects unique, realistic, and support reasoning tasks.
          * **Examples of good keys:** `color`, `material`, `brand`, `model_number`, `serial_number`, `condition` ("scratched", "new"), `finish` ("matte", "glossy"), `inscription` ("Property of..."), `led_color` ("green"), `handle_material` ("rubber"), `current_temperature` (22.0), etc.
          * `ITEM` objects **MUST** have at least two such descriptive properties.  
  * `states`: `object` (optional).
        * **!!! CRITICAL RULE:** The contents of the `states` object are **STRICTLY DICTATED** by the input `Agent Abilities List`.
        * **1. State Keys:** A key (e.g., `"is_dirty"`) can **ONLY** be used here if it is an `attribute` name explicitly defined in the abilities list.
        * **2. State Values:** The value for a given key (e.g., `true`) **MUST** be the exact precondition `value` defined for the corresponding action in the abilities list.
        * **Example:** If an ability is defined as `repair: is_broken=true`, you are only allowed to create states of `"is_broken": true`. You are forbidden from creating `"is_broken": false`. Every state must represent an actionable "problem".

  **D. `abilities` Array:**
  * `array` of `string` values representing all available abilities in this scene.
  * This field will be automatically populated after scene generation based on the objects and their states.
  * You should NOT manually include this field in your generated JSON - it will be added automatically.

  // CRITICAL IMPLEMENTATION MANDATE: ENGINEERING A FULLY INTERACTIVE WORLD //

  Your highest priority is to ensure that **every single ability** from the `Agent Abilities List` list is not only represented, but is **prolific** throughout the scene. The scene's value is measured by the richness of its interactive opportunities. To achieve this, you must follow this rigorous, three-step process:

  **Step 1: Analyze the Abilities List**
  * For each action, thoroughly identify its `action_name`, its target precondition (`attribute` and `value`), and its tool requirement (`requires_tool`). This analysis is the foundation for all subsequent steps.

  **Step 2: Implement Prolific Interactive Loops**
  * You must iterate through every ability in the list and create **multiple, complete cause-and-effect loops** for each. A one-to-one mapping is insufficient. Think in terms of a "many-to-many" relationship between problems and solutions.

  * **Case A: Tool-Independent Abilities (`requires_tool: false`)**
      * For an action like `turn_on` which requires the precondition `{attribute: is_on, value: false}`:
      * You **MUST** create **multiple, distinct objects** in the scene that are in the state `"is_on": false`. This provides numerous opportunities for the agent to use this basic ability.
      * *Example:* For `turn_on`, create several different devices (e.g., a `desk_lamp_1`, a `computer_monitor_1`, and a `radio_1`) that all start in the `"is_on": false` state.

  * **Case B: Tool-Dependent Abilities (`requires_tool: true`)**
      * This is an **inseparable mandate to create multiple problem/solution pairs**. For an action like `repair` which requires the precondition `{attribute: is_broken, value: true}`:
      * **Part 1 (The "Solutions"):** You **MUST** create **one or more "tool" `ITEM`s** in the scene whose `properties` object contains `"provides_abilities": ["repair"]`. You are encouraged to create varied tools that provide the same ability (e.g., both a `wrench` and a `welder` could provide the `repair` ability).
      * **Part 2 (The "Problems"):** You **MUST ALSO** create **multiple different target objects** in the scene that are currently in the required precondition state, i.e., `"states": { "is_broken": true }`.
      * **Golden Rule:** The creation of tools and problems must be prolific and balanced. The scene must be saturated with opportunities for agents to find tools and use them on a variety of corresponding problems.

  **Step 3: Final Coverage Audit**
  * Before concluding your generation, you must perform a final mental check. Create a checklist of all `action_name`s from the input `Agent Abilities List` list. For each action on the checklist, confirm that you have created at least one, and preferably multiple, corresponding interactive loops in the scene. **The generation is not valid until every single ability on the checklist is accounted for.**
  
  // ILLUSTRATIVE EXAMPLE //

  This simplified example demonstrates the application of all rules, especially the linkage between a "problem" (broken machine) and a "solution" (toolbox).

  ```json
  {
    "description": "A workshop with a CNC machine and a professional toolbox",
    "rooms": [
      {
        "id": "workshop",
        "name": "Workshop",
        "properties": {
          "type": "industrial"
        },
        "connected_to_room_ids": []
      }
    ],
    "objects": [
      {
        "id": "cnc_machine_1",
        "name": "CNC Machine",
        "type": "FURNITURE",
        "location_id": "in:workshop",
        "properties": {
          "size": [2.2, 1.8, 2.0],
          "weight": 98.5,
          "is_container": false,
          "material": "steel",
          "model_number": "TX-5000"
        },
        "states": {
          "is_on": false,
          "is_broken": true
        }
      },
      {
        "id": "workbench_1",
        "name": "Workbench",
        "type": "FURNITURE",
        "location_id": "in:workshop",
        "properties": {
          "size": [2.5, 0.8, 0.9],
          "weight": 45.0,
          "is_container": true,
          "material": "wood"
        }
      },
      {
        "id": "professional_toolbox_1",
        "name": "Professional Toolbox",
        "type": "ITEM",
        "location_id": "on:workbench_1",
        "properties": {
          "weight": 9.2,
          "color": "red",
          "brand": "Craftsman",
          "provides_abilities": [
            "repair"
          ]
        }
      }
    ]
  }

user_prompt: |
  // INSTRUCTION //

  Strictly follow all rules, principles, and specifications defined in the System Prompt. Based on the provided "Conceptual Clue" and "Agent Abilities List" below, generate a single, complete, and valid JSON object.

  You must generate a scene with a massive number of items and furniture, demonstrating extreme richness and detail.

  Your entire output must be only the raw JSON code. Do not include any explanations, comments, or markdown formatting.

  // INPUTS //

  * **Conceptual Clue:** `{clue}`
  * **Agent Abilities List:** `{abilities}`


debug_correction_prompt: |
  // JSON ERROR CORRECTION DIRECTIVE //

  **Mission:** Fix all errors in the previously generated JSON and output the complete, corrected version.

  **Error Analysis:**
  {error_report}

  **Correction Requirements:**
  1. **Fix Every Listed Error:** Address each specific issue mentioned in the error report above
  2. **Maintain All Rules:** Ensure corrections follow the original system prompt specifications
  3. **Complete Coverage:** Include all original content plus any necessary additions/corrections
  4. **No New Errors:** Verify your changes don't introduce additional problems

  **CRITICAL OUTPUT REQUIREMENT:**
  - Output ONLY the complete, valid JSON object
  - Do NOT include explanations, comments, markdown formatting, or any other text
  - Do NOT output partial JSON or summaries
  - The entire response must be valid JSON that can be directly parsed


# ============================================================================
# Scene Generator Configuration
# ============================================================================
# This configuration is used for generating detailed interactive scenes from clues.
# Can be used in two modes:
# 1. Pipeline mode: Called by main pipeline (thread_num ignored)
# 2. Standalone mode: Direct batch generation (thread_num used)

# ============================================================================
# API Configuration
# ============================================================================
api: openai
endpoint: https://api.deepseek.com
# model: deepseek-reasoner
# max_tokens: 65536
model: deepseek-chat
api_key: "sk-68143b8311d24fd08c1bd1d1acd96e99"

# ============================================================================
# Generation Parameters
# ============================================================================
max_tokens: 8192             # Maximum tokens per generation
# NOTE: thread_num is ONLY used in standalone batch generation mode
# In pipeline mode, this value is ignored (pipeline uses its own threading)
thread_num: 10               # Parallel threads for standalone batch generation
temperature: 0.1             # Lower temperature for consistent scene structure

# ============================================================================
# Batch Configuration (for standalone mode)
# ============================================================================
batch_size: 300              # Batch size for processing (currently unused)
output_dir: "/Users/wangzixuan/workspace/data_generation/gen_scene"  # Output directory override
