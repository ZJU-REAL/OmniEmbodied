{
  "id": 1,
  "raw": "\nRetrieved from http://www.mathworks.es/es/help/dsp/examples/working-with-fixed-point-direct-form-fir-filters.html?nocookie=true\nText:\nDocumentation Center\n\n  • Trials\n  • Product Updates\n\nWorking with Fixed-Point Direct-Form FIR Filters\n\nThis example shows how to design FIR filters implemented with the direct-form structure using fixed-point arithmetic. This example requires a Fixed-Point Designer™ license.\n\nSee also Getting Started with Fixed-Point Filters\n\nDesigning the Filter\n\nThe FIR filter to use is not critical. Since we will use the direct-form structure, it doesn't even need to have linear phase. For this example we will use a simple least-squares design.\n\nf=fdesign.lowpass('N,Fp,Fst',80,.11,.19); % Specifications\n\nA filter object results from the design method. It associates coefficients with a particular filter structure, here a direct-form FIR structure.\n\nh = design(f, 'firls', 'Wpass', 1, 'WStop', 100, ...\n    'FilterStructure', 'dffir');\nh =\n     FilterStructure: 'Direct-Form FIR'\n          Arithmetic: 'fixed'          \n           Numerator: [1x81 double]    \n    PersistentMemory: false            \n     CoeffWordLength: 16             \n      CoeffAutoScale: true           \n              Signed: true           \n     InputWordLength: 16             \n     InputFracLength: 15             \n     FilterInternals: 'FullPrecision'\n\nComparing Quantized Coefficients to Non-Quantized Coefficients\n\nThere are several parameters for a fixed-point direct-form FIR filter. To start with, it is best to concentrate on the coefficient wordlength and fractionlength (scaling). First we use the Filter Visualization Tool to compare the quantized coefficients to the nonquantized (reference) coefficients.\n\nhfvt = fvtool(h, 'legend', 'on', 'Color', 'white');\n\nDetermining the Number of Bits being Used\n\nTo determine the number of bits being used in the fixed-point filter, we simply look at the CoeffWordlength. To determine how they are being scaled, we can look at the CoeffAutoScale state.\n\nans =\n\n\nans =\n\n\nThis tells us that 16 bits are being used to represent the coefficients, and the least-significant bit (LSB) is weighed by 2^(-17). 16 bits is just the default number used for coefficients, but the 2^(-17) weight has been computed automatically to represent the coefficients with the best precision possible. This is controlled through the 'CoeffAutoScale' property. This property can be set to false if manual control of the coefficient scaling is desired. We simply verify that auto scaling is enabled here:\n\nget(h,'CoeffAutoScale') % Returns a logical true\nans =\n\n\nDetermining the Proper Coefficient Word Length\n\nWe can make several copies of the filter to try different word lengths. Allowing the coefficient auto scaling to determine the best precision in each case.\n\nh1 = copy(h);\nset(h1,'CoeffWordLength',12); % Use 12 bits\nh2 = copy(h);\nset(h2,'CoeffWordLength',24); % Use 24 bits\nhref = reffilter(h);\nset(hfvt, 'Filters', [href, h1, h, h2]);\nset(hfvt,'ShowReference','off'); % Reference already displayed once\nlegend(hfvt,'Reference filter','12 bits','16 bits','24 bits');\n\n12 bits are clearly not enough to faithfully represent this filter. 16 bits may be enough for most applications, so we will continue to use 16 bits in this example. As a rule-of-thumb, one should expect an attainable attenuation of about 5 dB per bit.\n\nFixed-Point Filtering\n\nOur main purpose is to evaluate the accuracy of the fixed-point filter when compared to a double-precision floating point version. We will see that it is not sufficient to have a faithful representation of the coefficients that keep the magnitude response approximately the same.\n\nGenerating Training Input Data\n\nSince we just want to evaluate accuracy, we will use some random data to filter and compare against. We will create a quantizer, with a range of [-1,1) to generate random uniformly distributed white-noise data using 16 bits of wordlength.\n\nrng(0,'twister'); % Intialize random generator to get reproducible results\nq = quantizer([16,15],'RoundMode','round');\nxq = randquant(q,1000,1); % 1000 Data points in the range [-1,1)\nxin = fi(xq,true,16,15);\n\nGenerating a Baseline Output to Compare Against\n\nWhen evaluating accuracy of fixed-point filtering, there are three quantities to consider:\n\n1. The \"ideal\" output, this quantity is what we would like to compute. It is computed using the reference coefficients and double-precision floating-point arithmetic.\n\n2. The best we can hope for, this is the best we can hope to achieve. It is computed using the quantized coefficients and double-precision floating-point arithmetic.\n\n3. What we can actually compute, this is the output computed using the quantized coefficients and fixed-point arithmetic.\n\nClearly we want to compare what we can actually compute to the best we can hope for. This last quantity can be computed by casting the fixed-point filter to double and filtering with double-precision floating-point arithmetic.\n\nxdouble = double(xin);\nhdouble = double(h);\nydouble = filter(hdouble,xdouble);\n\nFor completeness we show how to compute the \"ideal\" output. And how much the effect of solely quantizing the coefficients affects the output of the filter.\n\nyideal = filter(href,xdouble);\nnorm(yideal-ydouble)     % total error\nans =\n\n\nnorm(yideal-ydouble,inf) % max deviation\nans =\n\n\nComputing the Fixed-Point Output\n\nNext we will perform the actual fixed-point filtering. Once again, the best we can hope to achieve is to have an output identical to ydouble.\n\ny = filter(h,xin);\nnorm(double(y)-ydouble)     % total error\nans =\n\n\nnorm(double(y)-ydouble,inf) % max deviation\nans =\n\n\nThe errors are exactly zero, showing that no quantization is being introduced in the accumulator. The products are set by default to full precision, so we know that no errors are occurring there. Finally the output have the same specifications as the accumulator which eliminates quantization error at the output completely.\n\nThe Advantages of Having Guard Bits\n\nIf compare the product settings, with the accumulator settings:\n\nDiscrete-Time FIR Filter (real)                                              \nFilter Structure  : Direct-Form FIR                                          \nFilter Length     : 81                                                       \nStable            : Yes                                                      \nLinear Phase      : Yes (Type 1)                                             \nArithmetic        : fixed                                                    \nNumerator         : s16,17 -> [-2.500000e-01 2.500000e-01)                   \nInput             : s16,15 -> [-1 1)                                         \nFilter Internals  : Full Precision                                           \n  Output          : s34,32 -> [-2 2)  (auto determined)                      \n  Product         : s31,32 -> [-2.500000e-01 2.500000e-01)  (auto determined)\n  Accumulator     : s34,32 -> [-2 2)  (auto determined)                      \n  Round Mode      : No rounding                                              \n  Overflow Mode   : No overflow                                              \n\nWe notice that the accumulator has 3 extra bits available. This is typical of most fixed-point DSP processors. These bits are usually referred to as guard bits. They provide a safety net for intermediate overflows. The easiest way of appreciating their value is to remove them and see what happens (we adjust the output setting accordingly),\n\n\nWe now enable quantization reports. The logging capability is integrated to the 'filter' method. It is triggered when the 'Logging' FI preference is 'on'. The stored report corresponds to the last simulation. It is overwritten each time the filter command is executed.\n\np = fipref; previousLoggingMode = p.LoggingMode;\nfipref('LoggingMode', 'on');\ny = filter(h,xin);\nR = qreport(h)\nR =\n                                                  Fixed-Point Report                                          \n                      Min              Max       |              Range              |      Number of Overflows\n         Input:      -0.9989624        0.9989624 |             -1       0.99996948 |              0/1000 (0%)\n        Output:      -0.2498605       0.24979357 |          -0.25             0.25 |              0/1000 (0%)\n       Product:     -0.14476998       0.14476998 |          -0.25             0.25 |             0/81000 (0%)\n   Accumulator:     -0.24998221       0.24997947 |          -0.25             0.25 |           806/80000 (1%)\n\nThe quantization report contains the minimum and maximum values that were recorded during the last simulation (values are logged before quantization), the range and the number of overflows of different internal signals. As expected, we can see that overflows are occurring in the accumulator.\n\nnorm(double(y)-ydouble)     % total error\nans =\n\n\nans =\n\n\n\nThe error is large now, because overflow occurred as can be seen in the plot.\n\nAvoiding Overflow with No Guard Bits\n\nIt is possible to not have overflow even if guard bits are not available. From the plots of y and ydouble, it was clear that one bit for the integer part was all that was required in this specific case to avoid overflow. We can improve the results slightly with this setting, but this is specific to the current filter coefficients and input signal.\n\ny = filter(h,xin);\nR = qreport(h)\nR =\n                                                  Fixed-Point Report                                          \n                      Min              Max       |              Range              |      Number of Overflows\n        Output:     -0.59239117        0.5617338 |             -1                1 |              0/1000 (0%)\n   Accumulator:     -0.65199985       0.57536921 |             -1                1 |             0/80000 (0%)\n\nThe quantization report let us verify that the overflows are eliminated and that the signals occupy the full range i.e. the scaling is optimal for this particular training data.\n\nnorm(double(y)-ydouble)     % total error\nans =\n\n\nans =\n\n\nThe error seems small because there is no output quantization error in this case. If we use 16 bits for the output, the error is much larger.\n\ny = filter(h,xin);\nnorm(double(y)-ydouble)     % total error\nans =\n\n\nans =\n\n\nfipref('LoggingMode', previousLoggingMode);\nWas this topic helpful?\n",
  "response": "### **Scene Concept: \"The Overloaded Signal Processing Lab\"**  \n\n#### **1. Overall Scene Theme and Core Concept**  \nA high-tech **Digital Signal Processing (DSP) Laboratory**, specializing in fixed-point filter design and hardware testing. The lab is in a state of controlled chaos—engineers are rushing to finalize a prototype filter system before a critical client demo.  \n\n**Why Multi-Agent?**  \n- **Heavy Equipment:** Some components (test rigs, server racks) are too bulky for one person.  \n- **Precision Collaboration:** Calibration requires simultaneous adjustments by multiple technicians.  \n- **Information Scattering:** Critical manuals, schematics, and error logs are spread across workstations.  \n\n#### **2. Spatial Layout and Area Descriptions**  \nThe lab is divided into interconnected zones:  \n\n1. **Main Workbench Area** – The central hub, cluttered with prototype boards, oscilloscopes, and soldering stations.  \n2. **Server & Computation Cluster** – A humming rack of FPGA test units and cooling vents.  \n3. **Storage & Component Shelves** – Overstuffed with labeled bins, spare PCBs, and calibration tools.  \n4. **Meeting Nook** – A cramped space with a whiteboard covered in filter equations and a coffee-stained requirements document.  \n5. **Isolation Chamber** – A soundproofed booth for precision signal testing, filled with tangled cables.  \n\n---  \n\n### **3. Detailed Area-by-Area Inventory**  \n\n#### **Area 1: Main Workbench**  \n**a. Anchor Furniture & Installations:**  \n- A **6-meter-long anti-static workbench**, divided into three zones:  \n  - Left: **Signal generator station** (a rack-mounted Agilent 33500B, bolted down).  \n  - Center: **Prototype DSP board** (a Xilinx Zynq FPGA, screwed into a test fixture).  \n  - Right: **Oscilloscope and logic analyzer** (Tektronix MDO3000, screen flickering with a frozen waveform).  \n\n**b. Key Interactive & Task-Relevant Objects:**  \n- **\"Golden Reference\" Filter Module** – A sealed aluminum case with a biometric lock (requires two engineers’ fingerprints). Inside: a double-precision floating-point filter board for comparison.  \n- **Calibration Jig** – A 25kg steel frame holding a micrometer-adjustable probe (needs two people to align).  \n- **Error Log Tablet** – A cracked Samsung tablet displaying overflow warnings (battery at 12%).  \n\n**c. Functional Ambient Objects:**  \n- **Soldering Station** – Hakko FX-888D, iron set to 340°C, sponge dry.  \n- **Component Bins** – Stacked plastic trays with labels: \"16-bit ADCs,\" \"Decoupling Caps (10μF),\" \"Misc. Jumper Wires.\"  \n- **Tool Cart** – Rolling cart with a stuck wheel, holding precision screwdrivers and a torque wrench.  \n\n**d. Background & Decorative Objects:**  \n- **\"Safety First!\" Poster** – Faded, with a coffee cup stain obscuring the emergency exit diagram.  \n- **Engineer’s Lunchbox** – Half-open, emitting a faint smell of tuna sandwich.  \n- **Doodle-Filled Notepad** – Scribbles include a cartoon dragon and \"FIX COEFF SCALING!!!\" in red Sharpie.  \n\n---  \n\n#### **Area 2: Server & Computation Cluster**  \n**a. Anchor Furniture & Installations:**  \n- **19-inch Server Rack** – 2m tall, housing:  \n  - Top: **FPGA Emulator** (Xilinx VCU1525, fans at 80% RPM).  \n  - Middle: **Noisy HDD Array** – A Synology NAS blinking amber (disk 3 failing).  \n  - Bottom: **Uninterruptible Power Supply** (APC Smart-UPS, beeping softly—battery at 23%).  \n\n**b. Key Interactive & Task-Relevant Objects:**  \n- **\"Critical\" Filter Coefficients File** – A USB drive taped to the rack with \"DO NOT OVERWRITE\" on masking tape.  \n- **Thermal Emergency Button** – Big red switch labeled \"COOLING OVERRIDE\" (requires two hands to press).  \n\n**c. Functional Ambient Objects:**  \n- **KVM Switch** – A worn-out Aten CS-1768, input stuck on \"Workstation 2.\"  \n- **Spare Cooling Fans** – Stacked in original packaging, one opened but missing screws.  \n\n**d. Background & Decorative Objects:**  \n- **\"Employee of the Month\" Certificate** – From 2018, slightly askew.  \n- **Sticky Note** – Reads \"PASSWORD: f!lterD3sign2024\" (partially peeled off).  \n\n---  \n\n#### **4. Scene Affordances and Embedded Potential**  \n\n**Collaborative Transportation Affordances:**  \n- **Calibration Jig (25kg, 1.2m long)** – Requires two agents to lift safely.  \n- **Server Rack Mounting Rails** – A heavy FPGA unit (35kg) is halfway slid out; needs stabilization.  \n\n**Reasoning & Tool-Use Affordances:**  \n- **Attribute-Based Reasoning:**  \n  - Among **five USB drives** on the workbench, the correct one has:  \n    - A **scratched \"Zynq Backup\" label**  \n    - **32GB capacity** (others are 16GB)  \n    - **Red casing** (distractor: a red screwdriver nearby).  \n- **Compound (Tool-Use) Reasoning:**  \n  - **Problem:** The oscilloscope is frozen.  \n  - **Solution:** A **hard reset button** is hidden behind a panel (requires a flathead screwdriver from the cart).  \n\n**Conclusion:**  \nThis lab is a playground for multi-agent tasks—precision hardware handling, collaborative debugging, and scavenger hunts for critical components amidst realistic clutter. Every object has a purpose, a state, and a potential failure mode."
}